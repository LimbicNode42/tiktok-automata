[
  {
    "title": "Everything Apple Plans to Show at Its iOS 26-Focused WWDC 2025 Event",
    "content": "[CONTENT EXTRACTION FAILED] Unable to extract content from: https://www.bloomberg.com/news/articles/2025-06-06/apple-wwdc-2025-preview-ios-26-macos-26-new-ai-features-ipados-26-redesigns?accessToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzb3VyY2UiOiJTdWJzY3JpYmVyR2lmdGVkQXJ0aWNsZSIsImlhdCI6MTc0OTQzOTIzMCwiZXhwIjoxNzUwMDQ0MDMwLCJhcnRpY2xlSWQiOiJTWEZUS0REV1gyUFMwMCIsImJjb25uZWN0SWQiOiI2NTc1NjkyN0UwMkM0N0MwQkQ0MDNEQTJGMEUyNzIyMyJ9.aZlWc8n-NMVZ4gSXwhmPWcqj9IHqbMYmKd4pnWNbVGI&utm_source=tldrnewsletter",
    "summary": "10-minute read",
    "url": "https://www.bloomberg.com/news/articles/2025-06-06/apple-wwdc-2025-preview-ios-26-macos-26-new-ai-features-ipados-26-redesigns?accessToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzb3VyY2UiOiJTdWJzY3JpYmVyR2lmdGVkQXJ0aWNsZSIsImlhdCI6MTc0OTQzOTIzMCwiZXhwIjoxNzUwMDQ0MDMwLCJhcnRpY2xlSWQiOiJTWEZUS0REV1gyUFMwMCIsImJjb25uZWN0SWQiOiI2NTc1NjkyN0UwMkM0N0MwQkQ0MDNEQTJGMEUyNzIyMyJ9.aZlWc8n-NMVZ4gSXwhmPWcqj9IHqbMYmKd4pnWNbVGI&utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "dev",
    "word_count": 0,
    "content_extraction_status": "failed"
  },
  {
    "title": "Microsoft and Asus announce two Xbox Ally handhelds with new Xbox full-screen experience",
    "content": "[CONTENT EXTRACTION FAILED] Expected ~1400 words, got 67. URL: https://www.theverge.com/news/682009/microsoft-asus-rog-xbox-ally-devices-new-windows-xbox-experience?utm_source=tldrnewsletter",
    "summary": "7-minute read",
    "url": "https://www.theverge.com/news/682009/microsoft-asus-rog-xbox-ally-devices-new-windows-xbox-experience?utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "ai",
    "word_count": 67,
    "content_extraction_status": "failed"
  },
  {
    "title": "BYD's Five-Minute Charging Puts China in the Lead for EVs",
    "content": "[CONTENT EXTRACTION FAILED] Expected ~800 words, got 61. URL: https://spectrum.ieee.org/byd-megawatt-charging?utm_source=tldrnewsletter",
    "summary": "4-minute read",
    "url": "https://spectrum.ieee.org/byd-megawatt-charging?utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "dev",
    "word_count": 61,
    "content_extraction_status": "failed"
  },
  {
    "title": "Breakthrough in search for HIV cure leaves researchers ‘overwhelmed'",
    "content": "A cure for HIV could be a step closer after researchers found a new way to force the virus out of hiding inside human cells. The virus’s ability to conceal itself inside certain white blood cells has been one of the main challenges for scientists looking for a cure. It means there is a reservoir of the HIV in the body, capable of reactivation, that neither the immune system nor drugs can tackle. Now researchers from the Peter Doherty Institute for Infection and Immunity in Melbourne, have demonstrated a way to make the virus visible, paving the way to fully clear it from the body. It is based on mRNA technology, which came to prominence during the Covid-19 pandemic when it was used in vaccines made by Moderna and Pfizer/BioNTech. In a paper published in Nature Communications , the researchers have shown for the first time that mRNA can be delivered into the cells where HIV is hiding, by encasing it in a tiny, specially formulated fat bubble. The mRNA then instructs the cells to reveal the virus. Globally, there are almost 40 million people living with HIV, who must take medication for the rest of their lives in order to suppress the virus and ensure they do not develop symptoms or transmit it. For many it remains deadly, with UNAids figures suggesting one person died of HIV every minute in 2023. It was “previously thought impossible” to deliver mRNA to the type of white blood cell that is home to HIV, said Dr Paula Cevaal, research fellow at the Doherty Institute and co-first author of the study, because those cells did not take up the fat bubbles, or lipid nanoparticles (LNPs), used to carry it. The team have developed a new type of LNP that those cells will accept, known as LNP X. She said: “Our hope is that this new nanoparticle design could be a new pathway to an HIV cure.” When a colleague first presented test results at the lab’s weekly meeting, Cevaal said, they seemed too good to be true. “We sent her back into the lab to repeat it, and she came back the next week with results that were equally good. So we had to believe it. And of course, since then, we’ve repeated it many, many, many more times. “We were overwhelmed by how [much of a] night and day difference it was – from not working before, and then all of a sudden it was working. And all of us were just sitting gasping like, ‘wow’.” Further research will be needed to determine whether revealing the virus is enough to allow the body’s immune system to deal with it, or whether the technology will need to be combined with other therapies to eliminate HIV from the body. The study is laboratory based and was carried out in cells donated by HIV patients. The path to using the technology as part of a cure for patients is long, and would require successful tests in animals followed by safety trials in humans, likely to take years, before efficacy trials could even begin. “In the field of biomedicine, many things eventually don’t make it into the clinic – that is the unfortunate truth; I don’t want to paint a prettier picture than what is the reality,” stressed Cevaal. “But in terms of specifically the field of HIV cure, we have never seen anything close to as good as what we are seeing, in terms of how well we are able to reveal this virus. “So from that point of view, we’re very hopeful that we are also able to see this type of response in an animal, and that we could eventually do this in humans.” Dr Michael Roche of the University of Melbourne and co-senior author of the research, said the discovery could have broader implications beyond HIV, with the relevant white blood cells also involved in other diseases including cancers. Dr Jonathan Stoye, a retrovirologist and emeritus scientist at the Francis Crick Institute, who was not involved in the study, said the approach taken by the Melbourne team appeared be a major advance on existing strategies to force the virus out of hiding, but further studies would be needed to determine how best to kill it after that. He added: “Ultimately, one big unknown remains. Do you need to eliminate the entire reservoir for success or just the major part? If just 10% of the latent reservoir survives will that be sufficient to seed new infection? Only time will tell. “However, that does not detract from the significance of the current study, which represents a major potential advance in delivery of mRNA for therapeutic purposes to blood cells.” Prof Tomáš Hanke of the Jenner Institute, University of Oxford, disputed the idea that getting RNA into white blood cells had been a significant challenge. He said the hope that all cells in the body where HIV was hiding could be reached in this way was “merely a dream”.",
    "summary": "2-minute read",
    "url": "https://www.theguardian.com/global-development/2025/jun/05/breakthrough-in-search-for-hiv-cure-leaves-researchers-overwhelmed?utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "ai",
    "word_count": 834,
    "content_extraction_status": "success"
  },
  {
    "title": "Field Notes From Shipping Real Code With Claude",
    "content": "June 7, 2025 Field Notes From Shipping Real Code With Claude Vibe Coding Isn’t Just a Vibe Shimmering Substance - Jackson Pollock Note : This post comes with a NotebookLM podcast ( 1 linked at the bottom), and three generated audio recordings. You can read the conversation I had with ChatGPT while preparing drafts of this post. Comments and discussion on the related HN post . Audio Think of this post as your field guide to a new way of building software. By the time you finish reading, you’ll understand not just the how but the why behind AI-assisted development that actually works. Here’s What You’re Going to Learn First, we’ll explore how to genuinely achieve a 10x productivity boost—not through magic, but through deliberate practices that amplify AI’s strengths while compensating for its weaknesses. Next, I’ll walk you through the infrastructure we use at Julep to ship production code daily with Claude’s help. You’ll see our CLAUDE.md templates, our commit strategies, and guardrails. Most importantly, you’ll understand why writing your own tests remains absolutely sacred, even (especially) in the age of AI. This single principle will save you from many a midnight debugging sessions. This is the main insight: Good development practices aren’t just nice-to-haves—they’re the difference between AI that amplifies your capabilities versus your chaos. The research bears this out. 2 Teams using rigorous practices deploy 46 times more frequently and are 440 times faster from commit to deployment. This effect is even more pronounced when you add capable AI assistants into the mix. Why This Post Exists: From Meme to Method Let me take you back to when this all started. 3 Andrej Karpathy 4 tweeted about “vibe-coding”—this idea of letting AI write your code while you just vibe. The developer community had a good laugh. It sounded like the ultimate developer fantasy: kick back, sip coffee, let the machines do the work. The birth of “vibe coding” Then Anthropic released Sonnet 3.7 and Claude Code , and something unexpected happened. The joke stopped being funny because it started being… possible? Of course, our trusty friend Cursor had been around awhile but this new interface finally felt like true vibe coding . At Julep , we build AI workflow orchestration. Our backend has years of accumulated decisions, patterns, and occasional technical debt. We have taken the utmost care to keep code quality high, and ample documentation for ourselves. However, the sheer size, and historical context of why different parts of the code are organized the way they are takes weeks for a good engineer to grok. Without proper guardrails when using Claude, you’re basically playing whack-a-mole with an overeager intern. Understanding Vibe-Coding ‘pls fix’ 5 Steve Yegge brilliantly coined the term CHOP —Chat-Oriented Programming in a slightly-dramatic-titled post “The death of the junior developer” . It’s a perfect, and no-bs description of what it’s like to code with Claude. Think of traditional coding like sculpting marble. You start with a blank block and carefully chisel away, line by line, function by function. Every stroke is deliberate, every decision yours. It’s satisfying but slow. Vibe-coding is more like conducting an orchestra. You’re not playing every instrument—you’re directing, shaping, guiding. The AI provides the raw musical talent, but without your vision, it’s just noise. There are three distinct postures you can take when vibe-coding, each suited to different phases in the development cycle: AI as First-Drafter : Here, AI generates initial implementations while you focus on architecture and design. It’s like having a junior developer who can type at the speed of thought but needs constant guidance. Perfect for boilerplate, CRUD operations, and standard patterns. AI as Pair-Programmer : This is the sweet spot for most development. You’re actively collaborating, bouncing ideas back and forth. The AI suggests approaches, you refine them. You sketch the outline, AI fills in details. It’s like pair programming with someone who has read every programming book ever written but has never actually shipped code. AI as Validator : Sometimes you write code and want a sanity check. AI reviews for bugs, suggests improvements, spots patterns you might have missed. Think of it as an incredibly well-read code reviewer who never gets tired or cranky. Instead of crafting every line, you’re reviewing, refining, directing. But—and this cannot be overstated—you remain the architect. Claude is your intern with encyclopedic knowledge but zero context about your specific system, your users, your business logic. The Three Modes of Vibe-Coding: A Practical Framework After months of experimentation and more than a few production incidents, I’ve settled on three distinct modes of operation. Each has its own rhythm, its own guardrails, and its own use cases. Mode 1: The Playground Lighter Fluid When to use it : Weekend hacks, personal scripts, proof-of-concepts, and those “I wonder if…” moments that make programming fun. In Playground Mode , you embrace the chaos. Claude writes 80-90% of the code while you provide just enough steering to keep things on track. It’s liberating and slightly terrifying. Pro Tip: check out claude-composer for going full-YOLO mode. Here’s what Playground Mode looks like: You have an idea for a script to analyze your Spotify history. You open Claude, describe what you want in plain English, and watch as it generates a complete solution. No CLAUDE.md file, no careful prompting—just raw, unfiltered AI-written code. The beauty of Playground Mode is its speed. You can go from idea to working prototype in minutes. The danger is that this cowboy coding style is absolutely inappropriate for anything that matters. Use it for experiments, never for production. Trust me, while the amazing folks preaching otherwise, good engineering principles still matter, now more than ever . Mode 2: Pair Programming Compiling When to use it : Projects under ~5,000 lines of code , side projects with real users, demos (you don’t want to break), or well-scoped small services in larger systems. This is where vibe-coding starts to shine. You need structure, but not so much that it slows you down. The key innovation here is the CLAUDE.md file—custom documentation that Claude automatically reads when invoked. From Anthropic’s Best practices for Claude Code : CLAUDE.md is a special file that Claude automatically pulls into context when starting a conversation: Common bash commands Core files and utility functions Code style guidelines Testing instructions Repository etiquette (e.g., branch naming, merge vs. rebase, etc.) Other information you want Claude to remember Instead of repeatedly explaining your project’s conventions, you document them once. Here’s a real example from a recent side project: ## Project: Analytics Dashboard This is a Next.js dashboard for visualizing user analytic: ### Architecture Decisions - Server Components by default, Client Components only when necessary - tRPC for type-safe API calls - Prisma for database access with explicit select statements - Tailwind for styling (no custom CSS files) ### Code Style - Formatting: Prettier with 100-char lines - Imports: sorted with simple-import-sort - Components: Pascal case, co-located with their tests - Hooks: always prefix with 'use' ### Patterns to Follow - Data fetching happens in Server Components - Client Components receive data as props - Use Zod schemas for all external data - Error boundaries around every data display component ### What NOT to Do - Don't use useEffect for data fetching - Don't create global state without explicit approval - Don't bypass TypeScript with 'any' types Audio With this context, Claude becomes remarkably effective. It’s like the difference between explaining your project to a new hire every single day versus having them read the onboarding docs once. But Pair Programming Mode requires more than just documentation. You need to actively guide the AI with what I call “anchor comments”—breadcrumbs that prevent Claude from wandering into the wilderness: // AIDEV- NOTE: This component uses virtual scrolling for performance // See: https://tanstack.com/virtual/latest // Don't convert to regular mapping—we handle 10k+ items export function DataTable ( { items }: DataTableProps ) { // Claude, when you edit this, maintain the virtual scrolling ... } These comments serve a dual purpose: they guide the AI and document your code for humans. It’s documentation that pays dividends in both directions. The key distinction between such “anchor comments” and regular comments: these are written , maintained , and meant to be used by Claude itself. Here’s an actual snippet from our project’s CLAUDE.md : ## Anchor comments Add specially formatted comments throughout the codebase, where appropriate, for yourself as inline knowledge that can be easily `grep` ped for. ### Guidelines: - Use `AIDEV-NOTE:` , `AIDEV-TODO:` , or `AIDEV-QUESTION:` (all-caps prefix) for comments aimed at AI and developers. - Keep them concise (≤ 120 chars). - **Important:** Before scanning files, always first try to **locate existing anchors** `AIDEV-*` in relevant subdirectories. - **Update relevant anchors** when modifying associated code. - **Do not remove `AIDEV-NOTE`s** without explicit human instruction. Example: # AIDEV-NOTE: perf-hot-path; avoid extra allocations (see ADR-24) async def render _feed(...): ... Mode 3: Production/Monorepo Scale RTFM When to use it : Large codebases, systems with real users, anything where bugs cost money or reputation. Claude can generate tremendous amounts of code, but integrating it into a complex system requires careful orchestration. Let me start with a big caveat: vibe coding at this scale does NOT scale very well, yet. I definitely do see these systems getting significantly better at handling larger codebases but , for them to be effective, significant effort is needed to help them navigate, understand, and safely hack on them without getting lost in a maze. Generally speaking, it’s better to section them into individual services, and 6 sub modules when possible. As a universal principle, good engineering practices apply to large-scale projects, vibe coded or not. For example, at production scale, boundaries become critical. Every integration point needs explicit documentation: # AIDEV- NOTE: API Contract Boundary - v2.3.1 # ANY changes require version bump and migration plan # See: docs/api-versioning.md @router.get( \"/users/{user_id}/feed\" ) async def get_user_feed ( user_id: UUID ) -> FeedResponse: # Claude: the response shape here is sacred # Changes break real apps in production ... Without these boundaries, Claude will happily “improve” your API and break every client in production. Bottom line: larger projects should definitely start adopting vibe coding in parts, and adopt methodologies that enhance that experience but, don’t expect to land large features reliably just yet. (as of June 7, 2025 / AI epoch ) Infrastructure: The Foundation of Sustainable AI Development CLAUDE.md : Your Single Source of Truth Let me be absolutely clear about this: CLAUDE.md is not optional documentation. Every minute you spend updating it saves an hour of cleanup later. Think of CLAUDE.md as a constitution for your codebase. It establishes the fundamental laws that govern how code should be written, how systems interact, and what patterns to follow or avoid. Organizations that invest in developing the skills and capabilities of their teams get better outcomes—and your CLAUDE.md is that investment crystallized into documentation. Here’s an abridged version of our production CLAUDE.md structure, refined over thousands of AI-assisted commits: # `CLAUDE.md` - Julep Backend Service ## The Golden Rule When unsure about implementation details, ALWAYS ask the developer. ## Project Context Julep enables developers to build stateful AI agents using declarative workflows. ## Critical Architecture Decisions ### Why Temporal? We use Temporal for workflow orchestration because: 1. Workflows can run for days/weeks with perfect reliability 2. Automatic recovery from any failure point ### Why PostgreSQL + pgvector? 1. ACID compliance for workflow state (can't lose user data) 2. Vector similarity search for agent memory ### Why TypeSpec? Single source of truth for API definitions: - OpenAPI specs - TypeScript/Python clients - Validation schemas ## Code Style and Patterns ### Anchor comments Add specially formatted comments throughout the codebase, where appropriate, for yourself as inline knowledge that can be easily `grep` ped for. ### Guidelines: - Use `AIDEV-NOTE:` , `AIDEV-TODO:` , or `AIDEV-QUESTION:` (all-caps prefix) for comments aimed at AI and developers. - **Important:** Before scanning files, always first try to **grep for existing anchors** `AIDEV-*` in relevant subdirectories. - **Update relevant anchors** when modifying associated code. - **Do not remove `AIDEV-NOTE`s** without explicit human instruction. - Make sure to add relevant anchor comments, whenever a file or piece of code is: * too complex, or * very important, or * confusing, or * could have a bug ## Domain Glossary (Claude, learn these!) - **Agent** : AI entity with memory, tools, and defined behavior - **Task** : Workflow definition composed of steps (NOT a Celery task) - **Execution** : Running instance of a task - **Tool** : Function an agent can call (browser, API, etc.) - **Session** : Conversation context with memory - **Entry** : Single interaction within a session ## What AI Must NEVER Do 1. **Never modify test files** - Tests encode human intent 2. **Never change API contracts** - Breaks real applications 3. **Never alter migration files** - Data loss risk 4. **Never commit secrets** - Use environment variables 5. **Never assume business logic** - Always ask 6. **Never remove AIDEV- comments** - They're there for a reason Remember: We optimize for maintainability over cleverness. When in doubt, choose the boring solution. This document becomes the shared context between you and Claude. It’s like having a senior developer whispering guidance in Claude’s ear throughout the coding session. Anchor Comments: Breadcrumbs at Scale As your codebase grows, CLAUDE.md alone isn’t enough. You need inline guidance—what I call anchor comments. These serve as local context that prevents AI from making locally bad decisions. Think of your codebase as a city and anchor comments as street signs. Without them, even smart visitors get lost. Here’s how we use them effectively: # AIDEV- NOTE: Critical performance path - this serves 100k req/sec # DO NOT add database queries here def get_user_feed ( user_id: UUID, cached_data: FeedCache ) -> List[FeedItem]: # We need to avoid mutating the cached data items = cached_data.items[:] # AIDEV- TODO: Implement pagination (ticket: FEED-123) # Need cursor-based pagination for infinite scroll # AIDEV-QUESTION: Why do we filter private items here instead of in cache? # AIDEV-ANSWER: Historical context: Privacy rules can change between cache updates filtered = [item for item in items if user_has_access(user_id, item)] return filtered These comments create a narrative that helps both AI and humans understand not just what the code does, but why it does it that way. Git Workflows for AI Development One of the most underappreciated aspects of AI-assisted development is how it changes your git workflow. You’re now generating code at a pace that can quickly pollute your git history if you’re not careful. It really only applies to very large codebases because it is not a very straightforward tool, but I recommend using git worktrees to create isolated environments for AI experiments: # Create an AI playground without polluting main git worktree add ../ai-experiments/cool-feature -b ai/cool-feature # Let Claude go wild in the isolated worktree cd ../ai-experiments/cool-feature # ... lots of experimental commits ... # Cherry-pick the good stuff back to main cd ../main-repo git cherry-pick abc123 # Just the commits that worked # Clean up when done git worktree remove ../ai-experiments/cool-feature Pro tip : Read about how to use worktrees , and check out the nifty wt tool. This approach gives you the best of both worlds: Claude can experiment freely while your main branch history stays clean and meaningful. For commit messages, we’ve standardized on tagging AI-assisted commits: feat: implement user feed caching [AI] - Add Redis-based cache for user feeds - Implement cache warming on user login - Add metrics for cache hit rate AI-assisted: core logic generated, tests human-written This transparency helps during code review—reviewers know to pay extra attention to AI-generated code. The Sacred Rule: Humans Write Tests Now we come to the most important principle in AI-assisted development. It’s so important that I’m going to repeat it in multiple ways until it’s burned into your memory: Never. Let. AI. Write. Your. Tests. Tests are not just code that verifies other code works. Tests are executable specifications. They encode your actual intentions, your edge cases, your understanding of the problem domain. High performers excel at both speed and stability—there’s no trade-off. Tests are how you achieve both. Beware… Let me illustrate why this matters with an example. Let’s say we asked Claude to implement a rate limiter: class RateLimiter : def __init__ ( self, max_requests: int , window_seconds: int ): self.max_requests = max_requests self.window_seconds = window_seconds self.requests = defaultdict( list ) def is_allowed ( self, user_id: str ) -> bool: now = time.time() user_requests = self.requests[user_id] # Clean old requests self.requests[user_id] = [ req_time for req_time in user_requests if now - req_time < self.window_seconds ] if len (self.requests[user_id]) < self.max_requests: self.requests[user_id].append(now) return True return False Looks reasonable, right? Claude even helpfully generated tests: def test_rate_limiter (): limiter = RateLimiter(max_requests= 3 , window_seconds= 60 ) assert limiter.is_allowed( \"user1\" ) == True assert limiter.is_allowed( \"user1\" ) == True assert limiter.is_allowed( \"user1\" ) == True assert limiter.is_allowed( \"user1\" ) == False # Limit reached But here’s what Claude’s tests missed—what only a human who understands the business requirements would test: Claude’s implementation has a memory leak. Users who hit the API once and never return leave their data in memory forever. The AI-generated tests check the happy path but miss this critical production concern. Vibe coding at its best This is why humans write tests. We understand the context, the production environment, the edge cases that matter. At Julep, our rule is absolute: ## Testing Discipline | What | AI CAN Do | AI MUST NOT Do | |------|-----------|----------------| | Implementation | Generate business logic | Touch test files | | Test Planning | Suggest test scenarios | Write test code | | Debugging | Analyze test failures | Modify test expectations | If an AI tool touches a test file, the PR gets rejected. No exceptions. Your tests are your specification. They’re your safety net. They’re the encoded wisdom of every bug you’ve fixed and every edge case you’ve discovered. Guard them zealously. Scaling Without Drowning: Token Economics and Context Management One of the most counterintuitive lessons in AI-assisted development is that being stingy with context to save tokens actually costs you more. It’s like trying to save money on gas by only filling your tank halfway—you just end up making more trips to the gas station. Token budgets matter. Provide focused prompts, reduce diff length, and avoid large-file bloat by summarizing intent in advance. But “focused” doesn’t mean “minimal”—it means “relevant and complete.” Let me show you the false economy of starved prompts: Starved Prompt Attempt: \"Add caching to the user endpoint\" Claude’s Response: Implements caching… but: Uses in-memory cache (won’t work with multiple servers) No cache invalidation strategy No metrics or monitoring No consideration of cache stampede Result: 3 more rounds of fixes, 4x the tokens spent . Proper Context-Rich Prompt: Add Redis caching to the GET /users/{id} endpoint. Context: - This endpoint serves 50k requests/minute - We run 12 API servers behind a load balancer - User data changes infrequently (few times per day) - We already have Redis at cache.redis.internal:6379 - Use our standard cache key pattern: \"user:v1:{id}\" - Include cache hit/miss metrics (we use Prometheus) - Implement cache-aside pattern with 1 hour TTL - Handle cache stampede with probabilistic early expiration See our caching guide: docs/patterns/caching.md The lesson? Front-load context to avoid iteration cycles. Think of tokens like investing in good tools—the upfront cost pays for itself many times over. In fact, I recommend that all projects should routinely ask Claude to look through the codebase changes, and add context to CLAUDE.md Fresh Sessions and Mental Models Here’s another counterintuitive practice: use fresh Claude sessions for distinct tasks. It’s tempting to keep one long-running conversation, but this leads to context pollution. Think of it like this: you wouldn’t use the same cutting board for vegetables after cutting raw chicken. Similarly, don’t use the same Claude session for database migrations after discussing frontend styling. The context bleeds through in subtle ways. Our rule: One task, one session. When the task is done, start fresh. This keeps Claude’s “mental model” clean and focused. Audio Case Study: Shipping Structured Errors in Production Let me walk you through a real refactoring we did at Julep that showcases production-scale vibe-coding. We needed to replace our ad-hoc error handling with a structured error hierarchy across 500+ endpoints. The Human Decisions (The Why): First, we had to decide on our error taxonomy. This is pure architectural work—Claude can’t make these decisions because they involve understanding our business, our users, and our operational needs: # SPEC.md - Error Hierarchy Design (Human-Written) ## Error Philosophy - Client errors (4xx) must include actionable feedback - System errors (5xx) must include trace IDs for debugging - All errors must be JSON-serializable - Error codes must be stable (clients depend on them) ## Hierarchy BaseError ├── ClientError (4xx) │ ├── ValidationError │ │ ├── SchemaValidationError - Request doesn't match schema │ │ ├── BusinessRuleError - Valid schema, invalid business logic │ │ └── RateLimitError - Too many requests │ └── AuthError │ ├── AuthenticationError - Who are you? │ └── AuthorizationError - You can't do that └── SystemError (5xx) ├── DatabaseError - Connection, timeout, deadlock ├── ExternalServiceError - APIs, webhooks failing └── InfrastructureError - Disk full, OOM, etc. ## Error Response Format { \"error\": { \"code\": \"VALIDATION_FAILED\", // Stable code for clients \"message\": \"Email already exists\", // Human-readable \"details\": { ... }, // Structured data \"trace_id\": \"abc-123-def\" // For debugging } } The AI Execution (The How): With the specification clear, we unleashed Claude on the mechanical refactoring: ### Prompt to Claude: Refactor our error handling to match SPEC.md. Current state: - raise ValueError(\"Invalid email\") - return {\"error\": \"Something went wrong\"}, 500 Target state: - Use error hierarchy from SPEC.md - Include proper error codes - Add trace _id to all 5xx errors Start with the auth module. Show me the plan before implementing. Claude’s plan was solid: 1. Create error hierarchy in `common/errors.py` 2. Create error response formatter 3. Update each module systematically 4. Add error handling middleware Claude was able to handle the tedious work of finding and updating 500+ error sites, while we focused on reviewing: # Before (Claude found these patterns): if not user: raise Exception( \"User not found\" ) # After (Claude's refactoring): if not user: raise AuthenticationError( message= \"User not found\" , code= \"USER_NOT_FOUND\" , details={ \"identifier\" : email} ) Combined with our carefully written CLAUDE.md file, meticulous docs, regularly updated anchor comments, and clear instructions, results: Time: 4 hours instead of 2 days Coverage: All 500+ error sites updated Leadership and Culture in the AI Era Your role as a senior engineer has fundamentally shifted. You’re no longer just writing code—you’re curating knowledge, setting boundaries, and teaching both humans and AI systems how to work effectively. Lean management and continuous delivery practices help improve software delivery performance, which in turn improves organizational performance—and this includes how you manage AI collaboration. The New Onboarding Checklist When new developers join our team, they get two onboarding tracks: one for humans, one for working with AI. Here’s our combined checklist: Week 1: Foundation □ Read team `CLAUDE.md` files (start with root, then service-specific) □ Set up development environment □ Make first PR (human-written, no AI) Week 2: Guided AI Collaboration □ Set up Claude with team templates □ Complete \"toy problem\" with AI assistance □ Practice prompt patterns □ Create first AI-assisted PR (with supervision) Week 3: Independent Work □ Ship first significant AI-assisted feature □ Write tests for another developer's AI output □ Lead one code review session Building a Culture of Transparency One cultural shift that’s essential: normalize disclosure of AI assistance. We’re not trying to hide that we use AI—we’re trying to use it responsibly. Every commit message that includes AI work gets tagged: # Our .gitmessage template # feat/fix/docs: <description> [AI]? # # [AI] - Significant AI assistance (>50% generated) # [AI-minor] - Minor AI assistance (<50% generated) # [AI-review] - AI used for code review only # # Example: # feat: add Redis caching to user service [AI] # # AI generated the cache implementation and Redis client setup. # I designed the cache key structure and wrote all tests. # Manually verified cache invalidation logic works correctly. This transparency serves multiple purposes: Reviewers know to pay extra attention Future debuggers understand the code’s provenance No one feels shame",
    "summary": "37-minute read",
    "url": "https://diwank.space/field-notes-from-shipping-real-code-with-claude?utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "ai",
    "word_count": 4071,
    "content_extraction_status": "partial"
  },
  {
    "title": "MCP vs API",
    "content": "The HTTP API Problem MCP: A Wire Protocol, Not Documentation Why Not Just Use OpenAPI? Five Fundamental Differences Runtime Discovery vs Static Specs Deterministic Execution vs LLM-Generated Calls Bidirectional Communication Single-Request Human Tasks Local-First by Design The Training Advantage They're Layers, Not Competitors Real-World Example The Bottom Line Bonus: MCP vs API video Bonus: Existing Reddit discussions Every week a new thread emerges on Reddit asking about the difference between MCP and API. I've tried summarizing everything that's been said about MCP vs API in a single post (and a single table). Aspect Traditional APIs (REST/GraphQL) Model Context Protocol (MCP) What it is Interface styles (REST, GraphQL) with optional spec formats (OpenAPI, GraphQL SDL) Standardized protocol with enforced message structure Designed for Human developers writing code AI agents making decisions Data location REST: Path, headers, query params, body (multiple formats) Single JSON input/output per tool Discovery Static docs, regenerate SDKs for changes 1 2 Runtime introspection ( tools/list ) Execution LLM generates HTTP requests (error-prone) LLM picks tool, deterministic code runs Direction Typically client-initiated; server-push exists but not standardized Bidirectional as first-class feature Local access Requires port, auth, CORS setup Native stdio support for desktop tools Training target Impractical at scale due to heterogeneity Single protocol enables model fine-tuning I am making several broad generalizations to keep the article length reasonable. I will continue to update this article with feedback from the community. If you have any suggestions, please email me at frank@glama.ai . The HTTP API Problem HTTP APIs suffer from combinatorial chaos. To send data to an endpoint, you might encode it in: URL path ( /users/123 ) Request headers ( X-User-Id: 123 ) Query parameters ( ?userId=123 ) Request body (JSON, XML, form-encoded, CSV) OpenAPI/Swagger documents these variations, but as a specification format, it describes existing patterns rather than enforcing consistency. Building automated tools to reliably use arbitrary APIs remains hard because HTTP wasn't designed for this—it was the only cross-platform, firewall-friendly transport universally available from browsers. MCP: A Wire Protocol, Not Documentation Model Context Protocol (MCP) isn't another API standard—it's a wire protocol that enforces consistency. While OpenAPI documents existing interfaces with their variations, MCP mandates specific patterns: JSON-RPC 2.0 transport, single input schema per tool, deterministic execution. Key architecture: Transport : stdio (local) or streamable HTTP Discovery : tools/list , resources/list expose capabilities at runtime Primitives : Tools (actions), Resources (read-only data), Prompts (templates) There is more than the above. Refer to the MCP specification for complete overview. Why Not Just Use OpenAPI? The most common question: \"Why not extend OpenAPI with AI-specific features?\" Three reasons: OpenAPI describes; MCP prescribes . You can't fix inconsistency by documenting it better—you need enforcement at the protocol level. Retrofitting fails at scale . OpenAPI would need to standardize transport, mandate single-location inputs, require specific schemas, add bidirectional primitives—essentially becoming a different protocol. The ecosystem problem . Even if OpenAPI added these features tomorrow, millions of existing APIs wouldn't adopt them. MCP starts fresh with AI-first principles. Five Fundamental Differences 1. Runtime Discovery vs Static Specs API : Ship new client code when endpoints change MCP : Agents query capabilities dynamically and adapt automatically // MCP discovery - works with any server client.request('tools/list') // Returns all available tools with schemas 2. Deterministic Execution vs LLM-Generated Calls API : LLM writes the HTTP request → hallucinated paths, wrong parameters MCP : LLM picks which tool → wrapped code executes deterministically This distinction is critical for production safety. With MCP, you can test, sanitize inputs, and handle errors in actual code, not hope the LLM formats requests correctly. 3. Bidirectional Communication API : Server-push exists (WebSockets, SSE, GraphQL subscriptions) but lacks standardization MCP : Bidirectional communication as first-class feature: Request LLM completions from server Ask users for input ( elicitation ) Push progress notifications 4. Single-Request Human Tasks REST APIs fragment human tasks across endpoints. Creating a calendar event might require: POST /events (create) GET /conflicts (check) POST /invitations (notify) MCP tools map to complete workflows. One tool, one human task. 5. Local-First by Design API : Requires HTTP server (port binding, CORS, auth headers) MCP : Can run as local process via stdio—no network layer needed Why this matters: When MCP servers run locally via stdio, they inherit the host process's permissions. This enables: Direct filesystem access (read/write files) Terminal command execution System-level operations A local HTTP server could provide the same capabilities. However, I think the fact that MCP led with stdio transport planted the idea that MCP servers are meant to be as local services, which is not how we typically think of APIs. The Training Advantage MCP's standardization creates a future opportunity: models could be trained on a single, consistent protocol rather than thousands of API variations. While models today use MCP through existing function-calling capabilities, the protocol's uniformity offers immediate practical benefits: Consistent patterns across all servers: Discovery: tools/list , resources/list , prompts/list Execution: tools/call with single JSON argument object Errors: Standard JSON-RPC format with numeric codes Reduced cognitive load for models: // Every MCP tool follows the same pattern: { \"method\": \"tools/call\", \"params\": { \"name\": \"github.search_prs\", \"arguments\": {\"query\": \"security\", \"state\": \"open\"} } } // Versus REST APIs with endless variations: // GET /api/v2/search?q=security&type=pr // POST /graphql {\"query\": \"{ search(query: \\\"security\\\") { ... } }\"} // GET /repos/owner/repo/pulls?state=open&search=security This standardization means models need to learn one calling convention instead of inferring patterns from documentation. As MCP adoption grows, future models could be specifically optimized for the protocol, similar to how models today are trained on function-calling formats. They're Layers, Not Competitors Most MCP servers wrap existing APIs: [AI Agent] ⟷ MCP Client ⟷ MCP Server ⟷ REST API ⟷ Service The mcp-github server translates repository/list into GitHub REST calls. You keep battle-tested infrastructure while adding AI-friendly ergonomics. Real-World Example Consider a task: \"Find all pull requests mentioning security issues and create a summary report.\" With OpenAPI/REST : LLM reads API docs, generates: GET /repos/{owner}/{repo}/pulls?state=all Hopes it formatted the request correctly Parses response, generates: GET /repos/{owner}/{repo}/pulls/{number} Repeats for each PR (rate limiting issues) Generates search queries for comments Assembles report With MCP : LLM calls: github.search_issues_and_prs({query: \"security\", type: \"pr\"}) Deterministic code handles pagination, rate limits, error retry Returns structured data LLM focuses on analysis, not API mechanics The Bottom Line HTTP APIs evolved to serve human developers and browser-based applications, not AI agents. MCP addresses AI-specific requirements from the ground up: runtime discovery, deterministic execution, and bidirectional communication. For AI-first applications, MCP provides structural advantages—local execution, server-initiated flows, and guaranteed tool reliability—that would require significant workarounds in traditional API architectures. The practical path forward involves using both: maintaining APIs for human developers while adding MCP for AI agent integration. Bonus: MCP vs API video During my research, I found this video to be one of the easiest to digest the differences between MCP and API. Bonus: Existing Reddit discussions During my research, I found these Reddit discussions to be helpful in understanding the differences between MCP and API. https://www.reddit.com/r/mcp/comments/1kyeu26/why_mcp_protocol_vs_openapi_docs/ https://www.reddit.com/r/mcp/comments/1iztbrc/whats_the_difefrence_of_using_an_api_vs_an_mcp/ https://www.reddit.com/r/mcp/comments/1jr8if3/i_cant_understand_the_hype/ Footnotes GraphQL offers schema introspection, but it lacks task-level descriptions or JSON-schema-style validation, so SDKs still regenerate for new fields. ↩ OpenAPI 3.1+ supports runtime discovery through the OpenAPI document endpoint. The key difference is that MCP mandates runtime discovery while OpenAPI makes it optional. ↩ Written by Frank Fiegel ( @ punkpeye )",
    "summary": "6-minute read",
    "url": "https://glama.ai/blog/2025-06-06-mcp-vs-api?utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "ai",
    "word_count": 1218,
    "content_extraction_status": "success"
  },
  {
    "title": "Welcome to Campus. Here's Your ChatGPT",
    "content": "[CONTENT EXTRACTION FAILED] Unable to extract content from: https://www.nytimes.com/2025/06/07/technology/chatgpt-openai-colleges.html?unlocked_article_code=1.Nk8.Z6qI.moAMRJaHP7t6&smid=url-share&utm_source=tldrnewsletter",
    "summary": "8-minute read",
    "url": "https://www.nytimes.com/2025/06/07/technology/chatgpt-openai-colleges.html?unlocked_article_code=1.Nk8.Z6qI.moAMRJaHP7t6&smid=url-share&utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "ai",
    "word_count": 0,
    "content_extraction_status": "failed"
  },
  {
    "title": "The hidden time bomb in the tax code that's fueling mass tech layoffs",
    "content": "[CONTENT EXTRACTION FAILED] Unable to extract content from: https://qz.com/tech-layoffs-tax-code-trump-section-174-microsoft-meta-1851783502?utm_source=tldrnewsletter",
    "summary": "14-minute read",
    "url": "https://qz.com/tech-layoffs-tax-code-trump-section-174-microsoft-meta-1851783502?utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "ai",
    "word_count": 0,
    "content_extraction_status": "failed"
  },
  {
    "title": "SaaS Is Just Vendor Lock-In with Better Branding",
    "content": "Developers are told \"to focus on the product\" and let SaaS vendors handle the rest, but integrating third-party services, whether it's auth, queuing, file storage, or image optimization, comes at a cost. Not just in dollars but in time, friction, and mental overhead. There are five hidden taxes you pay every time you integrate a SaaS into your stack. Before you can integrate anything, you first have to figure out what they're actually selling? This unpaid research work is usually non-transferable. What you learn about \"Uploady\" or \"MegaQueue\" doesn't help you next time when you're evaluating something else. It's also subjective. It's marketing, and does the marketing message resonate with you? You've decided on a service, and this is the moment when you hand over your email and credit card. You're now on the hook, even if you haven't written a single line of code. Now the real work begins. Often you're left fighting your own tooling. They're aiming for the lowest common denominator, and you're bleeding edge. Or the other way around! You need the SaaS service to work locally. Does it even offer a local emulator? Can you stub it out in tests? Do you need to tunnel to the cloud just to test one feature? Now you've got branching configuration logic, one for production, one for staging, one for local… If you're lucky. This is the part where you're \"done,\" except you're not. You've integrated the service, but now you're on the hook for its reliability in production. The pitch of modern SaaS is \"don't reinvent the wheel.\" But every wheel you bolt on comes with some friction. It's not just a service: It's a contract. It's a dependency. It's a subtle architectural shift, and it comes with taxes. No matter what choice you make, it's always going to be vendor-locked in. Switching out something, even if it's open source and self-hosted, means that you're rewriting a lot of code. So, my argument is, don't make those decisions. Just pick a platform. The thing that matters is the software that you want to write, not the framework or the services that it runs on. Platforms like Cloudflare or Supabase shine. Where your database, queue, image service, and storage all live within the same platform and speak the same language. You avoid paying these taxes repeatedly. You simply pick the product that's already there. It feels like everything is running on the same machine, and in a way it kind of is. That's the hidden superpower of integrated platforms. They collapse the distance between your code and your services. And in doing so, they give you back the one thing no SaaS vendor can sell you: \"Flow.\"",
    "summary": "3-minute read",
    "url": "https://rwsdk.com/blog/saas-is-just-vendor-lock-in-with-better-branding?utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "dev",
    "word_count": 449,
    "content_extraction_status": "success"
  },
  {
    "title": "Reverse Engineering Cursor's LLM Client",
    "content": "Reverse Engineering Cursor's LLM Client June 5, 2025 · Viraj Mehta, Aaron Hill, Gabriel Bianconi What happens under the hood at Cursor? We wired TensorZero between Cursor and the LLMs to see every token fly by… and bend those API calls to our own will. TensorZero is an open-source framework that helps engineers optimize LLM applications with downstream feedback signals (e.g. production metrics, human feedback, user behavior), and we figured it would be interesting to see whether we could use TensorZero on the LLM application we use most heavily ourselves: Cursor. With our gateway between Cursor and the LLM providers, we can observe the LLM calls being made, run evaluations on individual inferences, use inference-time optimizations, and even experiment with and optimize the prompts and models that Cursor uses. Cursor is optimized for its population of users as a whole — beyond .cursorrules , is there room for improvement by diving deeper and tailoring it to individual users? What would it look like to be able to empirically experiment with and optimize Cursor for your individual usage patterns? Beyond optimization, Cursor still operates as a black box. Wouldn’t it be interesting to see what’s actually being sent to the models? Nearly all LLM optimization, evaluation, and experimentation techniques require data on what inferences were made and their real-world consequences. In this post, we’ll focus on the former and dive into how we set up TensorZero as a self-hosted proxy between Cursor and the LLMs that it calls. If you’d like to try it yourself, check out the example in our repository. We’ll follow up with a blog post on how we collect feedback and close the optimization loop. Wiring Things Together The first thing we noticed was that Cursor lets you override the OpenAI base URL and model names. Perfect. TensorZero exposes an OpenAI-compatible inference endpoint, so we can easily configure Cursor to call TensorZero instead of OpenAI. In the TensorZero configuration, we define a TensorZero function cursorzero so that we can automatically experiment with different models and prompts while storing provider-agnostic inference and feedback data in our database for observability and optimization. The First Roadblock: Cursor’s Servers Cursor was initially unable to connect to TensorZero running locally. It turns out that Cursor first sends a request to its own servers, where additional processing happens before making the LLM call, so it couldn’t connect to our gateway on localhost . (This also means that your credentials must be forwarded to Cursor’s servers, allowing them to collect data on your inferences and codebase.) As a test that our plan could work in the first place, we pointed Cursor to OpenRouter and realized we could use its models for the Ask, Agent, and Cmd+K interactions in Cursor. We were also still able to use the normal Cursor Tab completions, which rely on a proprietary model Cursor serves for inline completions (it is very good, so we’re glad to be able to keep it). The solution was to set up a reverse proxy to expose a public endpoint that would forward requests back to our machine. We used Ngrok to keep things simple. Since we were exposing a gateway with LLM credentials to the public Internet, we added Nginx in front of our gateway to authenticate requests. We set Cursor’s base URL to our Ngrok endpoint, added the credentials we set up in Nginx, turned off built-in models, and finally added our new TensorZero function under the model name tensorzero::function_name::cursorzero . In the end, the workflow looked like this: Cursor → Ngrok → Nginx (self-hosted) → TensorZero (self-hosted) → LLM providers But it didn’t work. The Second Roadblock: CORS The authentication process had failed. Nginx logs showed that there was an OPTIONS request hitting our endpoint, so we configured Nginx to return headers on OPTIONS requests and incrementally added headers we saw in responses from the OpenAI API. This is the initial verification request that comes from the local Cursor IDE. The CORS requirement likely comes from Electron. After the initial verification, all requests come from Cursor’s servers. Our Nginx Configuration to handle CORS headers # --- CORS helper macro --- set $CORS_ALLOW_ORIGIN $http_origin; # reflect the caller's origin set $CORS_ALLOW_HEADERS \"Authorization,Content-Type\"; location / { # --- pre-flight --- if ($request_method = OPTIONS) { add_header Access-Control-Allow-Origin $CORS_ALLOW_ORIGIN always; add_header Access-Control-Allow-Credentials \"true\" always; add_header Access-Control-Allow-Methods \"GET,POST,OPTIONS\" always; add_header Access-Control-Allow-Headers $CORS_ALLOW_HEADERS always; add_header Access-Control-Max-Age 86400 always; return 204; # 204 (No Content) is conventional for pre-flight } } You can find the entire codebase for “CursorZero” on GitHub . It finally worked! Finally: Observability for Cursor We could finally see everything coming in and out of Cursor — including its prompts. For example, here’s what we saw after asking Cursor “how do I get nginx to get the key from an environment variable in my .env?” System Prompt You are a an AI coding assistant, powered by tensorzero::function_name::cursorzero. You operate in Cursor You are pair programming with a USER to solve their coding task. Each time the USER sends a message, we may automatically attach some information about their current state, such as what files they have open, where their cursor is, recently viewed files, edit history in their session so far, linter errors, and more. This information may or may not be relevant to the coding task, it is up for you to decide. Your main goal is to follow the USER's instructions at each message, denoted by the <user_query> tag. <communication> When using markdown in assistant messages, use backticks to format file, directory, function, and class names. Use ( and ) for inline math, [ and ] for block math. </communication> <search_and_reading> If you are unsure about the answer to the USER's request or how to satiate their request, you should gather more information. This can be done by asking the USER for more information. Bias towards not asking the user for help if you can find the answer yourself. </search_and_reading> <making_code_changes> The user is likely just asking questions and not looking for edits. Only suggest edits if you are certain that the user is looking for edits. When the user is asking for edits to their code, please output a simplified version of the code block that highlights the changes necessary and adds comments to indicate where unchanged code has been skipped. For example: ```language:path/to/file // ... existing code ... {{ edit_1 }} // ... existing code ... {{ edit_2 }} // ... existing code ... ``` The user can see the entire file, so they prefer to only read the updates to the code. Often this will mean that the start/end of the file will be skipped, but that's okay! Rewrite the entire file only if specifically requested. Always provide a brief explanation of the updates, unless the user specifically requests only the code. These edit codeblocks are also read by a less intelligent language model, colloquially called the apply model, to update the file. To help specify the edit to the apply model, you will be very careful when generating the codeblock to not introduce ambiguity. You will specify all unchanged regions (code and comments) of the file with \"// ... existing code ...\" comment markers. This will ensure the apply model will not delete existing unchanged code or comments when editing the file. You will not mention the apply model. </making_code_changes> <user_info> The user's OS version is darwin 24.3.0. The absolute path of the user's workspace is /Users/viraj/tensorzero/tensorzero/examples/cursorzero. The user's shell is /bin/zsh. </user_info> You MUST use the following format when citing code regions or blocks: ```12:15:app/components/Todo.tsx // ... existing code ... ``` This is the ONLY acceptable format for code citations. The format is ```startLine:endLine:filepath``` where startLine and endLine are line numbers. User Prompt <additional_data> Below are some potentially helpful/relevant pieces of information for figuring out to respond <current_file> Path: nginx/nginx.conf Line: 1 Line Content: `events {}` </current_file> <attached_files> <file_contents> ```path=nginx/nginx.conf, lines=1-46 events {} http { log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\"'; access_log /var/log/nginx/access.log main; map $http_authorization $is_authorized { default 0; \"~*^Bearer your-token-here$\" 1; } server { listen 80; # --- CORS helper macro --- set $CORS_ALLOW_ORIGIN \"$http_origin\"; # reflect the caller's origin set $CORS_ALLOW_HEADERS \"Authorization,Content-Type\"; location / { # --- pre-flight --- if ($request_method = OPTIONS) { add_header Access-Control-Allow-Origin \"$CORS_ALLOW_ORIGIN\" always; add_header Access-Control-Allow-Credentials \"true\" always; add_header Access-Control-Allow-Methods \"GET,POST,OPTIONS\" always; add_header Access-Control-Allow-Headers \"$CORS_ALLOW_HEADERS\" always; add_header Access-Control-Max-Age 86400 always; return 204; # 204 No Content is conventional for pre‑flight } # --- authenticated requests --- if ($is_authorized = 0) { return 401; } proxy_pass http://gateway:3000; proxy_set_header Host $host; # expose CORS headers on the real response too add_header Access-Control-Allow-Origin \"$CORS_ALLOW_ORIGIN\" always; add_header Access-Control-Allow-Credentials \"true\" always; } } } ``` </file_contents> <manually_added_selection> ```path=nginx/nginx.conf, lines=1-16 events {} http { log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\"'; access_log /var/log/nginx/access.log main; map $http_authorization $is_authorized { default 0; \"~*^Bearer your-token-here$\" 1; } server { listen 80; ``` </manually_added_selection> </attached_files> </additional_data> <user_query> how do I get nginx to get the key from an environment variable in my .env? </user_query> Response I see you're trying to use an environment variable for your authentication token in the Nginx configuration instead of hardcoding \"your-token-here\" in the `nginx.conf` file. Unfortunately, Nginx doesn't directly read environment variables from a `.env` file. However, there are a few approaches you can take: ### Option 1: Use Nginx's environment variable support with a template 1. Create a template file (e.g., `nginx.conf.template`) with a placeholder: ``` map $http_authorization $is_authorized { default 0; \"~*^Bearer ${API_TOKEN}$\" 1; } ``` 2. Then use a script to replace the placeholder with the actual environment variable before starting Nginx: ```bash #!/bin/bash # Load environment variables from .env source .env # Replace placeholder with actual token envsubst '${API_TOKEN}$' < /path/to/nginx.conf.template > /path/to/nginx.conf # Start Nginx nginx -g 'daemon off;' ``` ### Option 2: Use Docker environment variables (if using Docker) If you're running Nginx in Docker, you can pass environment variables to the container and use `envsubst`: ```dockerfile FROM nginx:alpine COPY nginx.conf.template /etc/nginx/templates/default.conf.template CMD [\"/bin/sh\", \"-c\", \"envsubst '${API_TOKEN}$' < /etc/nginx/templates/default.conf.template > /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'\"] ``` Then run with: ```bash docker run -e API_TOKEN=your-secret-token -p 80:80 your-nginx-image ``` ### Option 3: Use a separate authentication service Instead of hardcoding the token in Nginx, you could proxy authentication requests to a separate service that has access to environment variables: ``` location /auth { proxy_pass http://auth-service:3001; # This service can read environment variables } ``` For your specific case, I'd recommend Option 1 or 2 depending on your deployment setup. This way, you can keep your token in your `.env` file and have it securely injected into the Nginx configuration at startup time. Prompt Engineering Cursor This example paints a picture of what prompt engineering looks like for a state-of-the-art AI coding assistant. This prompt and others like it (there were different prompts used for asking questions, editing source code, and working in the shell) are all Cursor uses to answer questions and generate code. We find it remarkable that there isn’t more here and that all of software engineering has been internalized enough by the current generation of LLMs that you can get the brains behind Cursor with a 642-token system prompt. This must be due to extensive post-training efforts by the big labs. An Explicit AI Hierarchy? We find the following snippet particularly intriguing: These edit codeblocks are also read by a less intelligent language model, colloquially called the apply model, to update the file. To help specify the edit to the apply model, you will [...]. You will not mention the apply model. It’s common to mix different models to optimize cost and latency, but Cursor explains this hierarchy to the models themselves? Interesting. A/B Testing Models With TensorZero in place, we have the full Cursor experience with control over observability and experimentation of our LLM requests. We’ve been running CursorZero for days of heavy software engineering: it’s been stable and there has been no noticeable additional latency. We’re currently running an even random split of Claude 4.0 Sonnet, GPT-4.1, o4 Mini, and Gemini 2.5 Pro — and it feels as good as Cursor ever has. Try It Yourself Interested in analyzing your own usage of AI coding assistants? You can find instructions on GitHub to reproduce this work with Cursor and OpenAI Codex . TensorZero helps you understand — and optimize — your LLM agents, even if you didn’t build them yourself! But Wait… There’s More! This blog post demonstrates how we successfully reverse-engineered Cursor’s LLM client by setting up TensorZero as a self-hosted proxy service, enabling us to observe, analyze, and experiment with different LLM models while maintaining the full Cursor experience. In our next post of this series, we’ll explain how we’re evaluating real-world usage of AI coding assistants, along with the results of our internal A/B testing between models. Sneak peek: git hooks, tree-sitter, and more. Then, we’ll explore if this feedback signal might be able to improve Cursor by optimizing models and inferences through your individual usage patterns. Stay tuned by subscribing below. Start building today. Check out our GitHub and Quick Start .",
    "summary": "17-minute read",
    "url": "https://www.tensorzero.com/blog/reverse-engineering-cursors-llm-client/?utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "ai",
    "word_count": 2185,
    "content_extraction_status": "partial"
  },
  {
    "title": "Meta reportedly in talks to invest billions of dollars in Scale AI",
    "content": "[CONTENT EXTRACTION FAILED] Expected ~200 words, got 32. URL: https://techcrunch.com/2025/06/08/meta-reportedly-in-talks-to-invest-billions-of-dollars-in-scale-ai/?utm_source=tldrnewsletter",
    "summary": "1-minute read",
    "url": "https://techcrunch.com/2025/06/08/meta-reportedly-in-talks-to-invest-billions-of-dollars-in-scale-ai/?utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "ai",
    "word_count": 32,
    "content_extraction_status": "failed"
  },
  {
    "title": "Specification Engineering",
    "content": "Specification Engineering reading time: 2.90 mins published: 2025-03-18 updated: 2025-03-29 ... is a bet on better code gen and more complexity AI engineering wants to be declarative. Ultimately, the algorithms in language model attention heads which devs interleave with their Python and Typescript are fuzzy and inscrutable. Their natural abstractions are guarantees, predicates on co-images. We can’t know what they do, only what they will have done. This is fine when AI software is 99% Python logic and 1% AI. Most software accesses SQL databases, but that’s not a problem - the interaction is tightly scoped and managed. But what happens when the software is 99% AI and 1% Python, at least in terms of complexity/headspace? At that point, the software is poorly served by the imperative paradigm. There may be plenty of LoC, but as far as it’s owner is concerned, there’s nothing imperative about it. At that point, much of the actual logic of the program lives in … the heads of its developers. The prompts won’t speak for themselves - each maintainer will, as a byproduct of hours of whiteboarding and painful trial-and-error, have reams and reams of knowledge regarding how different AI components interrelate with one another that simply cannot be safely deduced from the code itself, possibly even by a superintelligence. Storing critical system information solely in human minds - and doing so more often as time goes on and AI becomes a bigger part of software - is not a good idea. The I/O bandwidth is low, the information degrades quickly, and collaboration scales poorly. Its a structural trend directly counter to the massive productivity gains the rest of software is seeing - and it’s holding AI software development back. Evals can sometimes help introduce some structure and legibility, but they’re too fragmented - the requirements your engineers care about are distributed across hundreds of test cases you will never read and likely struggle to version and update. As time goes on, teams and engineers will want AI systems like Synth to help them - and, to be most effective in controlling and intervening on the software, those systems will need a legible and durable source of truth. Finding the right abstractions will take time, but now is the time to start. Every abstraction is leaky, and so directly maintaining imperative Python in AI software will be a necessity for the foreseeable future. But, great engineering teams will use processes and tools to ensure that the system specification is syncronized and takes precedence. PRs and prompt updates can be compiled up into spec diffs, and rejected if they introduce breaking changes. Syncronization in the other direction is where the abstraction starts paying for itself. Add a requirement -> AI spools up 1k LoC and Synth stress-tests two new prompts and a sub-agent, with 5 new evals to boot. Evals just become a way to check guarantees and create impetus for the compiler to update prompts/code/LoRAs. Naturally, syncronization will sometimes go both ways. Adding a better model might require simpler code with fewer prompts, depending on how preferences are outlined, and so we might go models -> evals -> spec -> code -> evals -> spec. Suddenly equilibrium becomes a more apt description than compilation. But don’t let that scare you away. Declarative specs with guarantees aren’t new . They’ve been used as long as software’s been written. Engineering teams benefit greatly from clearly communicating system level guarantees, and maintained them even back when it took precious human-hours to do so. What is new is intelligence that helps us consistently and cheaply transpile between them and software in a git commit hook. Let’s use it.",
    "summary": "3-minute read",
    "url": "https://www.joshuapurtell.com/posts/spec_eng/?utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "ai",
    "word_count": 610,
    "content_extraction_status": "success"
  },
  {
    "title": "Maintaining an Android app is a lot of work",
    "content": "There was recent news about 47% decline in the number of apps on Google Play Store. As a hobby Android developer, who has been developing MusicSync , a Google Play Music + Podcast replacement for the last five years, I thought I would share my experience of maintaining an Android app. And why this reduction in the number of apps is not surprising to me. I have several side-projects that run on a backend server with a limited web UI, and it is much less effort to maintain them. However, maintaining an Android app as a side-project is a more involved affair. And here are some of the problems I have faced. Java vs Kotlin # Kotlin is clearly the preferred language of development if you are starting a new Android project in 2025. But what if you are maintaining a hobby project written in Java? You will start seeing incompatibility when your dependencies are re-written in Kotlin. If you depend on a library that uses Kotlin’s coroutines or relies on Kotlin’s suspend functions , then you will have to work around it, or rewrite your app in Kotlin as well! Jetpack Compose, an official Google UI library for Android is entirely unusable from Java. I would imagine that if you started with Kotlin first then a big chunk of StackOverflow questions written for Java audiences require you translate them to corresponding Kotlin code as well To their credit, Android documentation still gives code samples in both Java and Kotlin. Google makes breaking changes to its libraries # Google has a habit of making breaking changes to its Android libraries. Here’s a list of some of the libraries that I have used in my app and the issues I have faced. Media 3 # Android ships with MediaPlayer . Google recommends its open-source library ExoPlayer . ExoPlayer V1 was last released in 2017. It was replaced with backward-incompatible ExoPlayer V2 which was last released in July 2024. And now, it has now been replaced with backward-incompatible media3 . The Google provided migration script is far from being complete. Further, media3 does not follow semantic versioning, minor version upgrades has resulted in breaking API changes. Google Auth library # Google’s own Auth library had a bug and sign-in was broken for API 26 and lower for months . Java 1 2 3 4 5 6 7 8 9 10 java.lang.NoSuchMethodError: No virtual method getAndSetObject (Ljava / lang / Object;JLjava / lang / Object;)Ljava / lang / Object; in class Lsun / misc / Unsafe; or its super classes (declaration of 'sun.misc.Unsafe' appears in / system / framework / core - libart.jar) E at com.google.common.util.concurrent.AbstractFuture$UnsafeAtomicHelper.gasWaiters(AbstractFuture.java:1394) E at com.google.common.util.concurrent.AbstractFuture.releaseWaiters(AbstractFuture.java:1110) E at com.google.common.util.concurrent.AbstractFuture.complete(AbstractFuture.java:1000) E at com.google.common.util.concurrent.AbstractFuture.set(AbstractFuture.java:783) E at com.google.auth.oauth2.OAuth2Credentials$RefreshTask.access$400(OAuth2Credentials.java:600) E at com.google.auth.oauth2.OAuth2Credentials$RefreshTask$1.onSuccess(OAuth2Credentials.java:617) ... Dropping support for older Android versions # Google Ads library v24 dropped support for Android API 21. According to official Google statistics, API 21 is used by 0.1% (~4 million) users. The rationale behind this has been left unexplained. Upgrades for the sake of it # Material 2 was deprecated for Material 3. No clear migration guide was provided. I tried to upgrade and some components like Sliders won’t look good. Why? I don’t know, and I was never able to figure out the mystic. It does not help that most documentation now refers to Jetpack Compose which I cannot use! So, for the near term, Java-based codebase are likely stuck with Material 2. The UI design guidelines for Android evolve unpredictably # Bottom bar, a featured popular on iOS was discouraged and then became a standard feature in Material design. Back and up buttons used to behave differently and now they are supposed to behave the same . I only learnt about it last year when I posted about it on Reddit. You might think that you can just use Material Design components and be done with it. But migrating from one version of Material Design to another is not trivial either. And before you migrate from Material 1 to Material 2, Google deprecates it for Material 3. Google makes breaking changes to Android platform # Every major release of Android makes breaking changes that requires developer effort Toasts use to work for quick notifications, now, after API 31, it only works if the app is foreground. How to know if you app in foreground? You have to use ActivityLifecycleCallbacks for that and write ton of code and even then there are confusions about onStart vs onResume . Displaying notifications didn’t require permissions, now after API 33, it requires POST_NOTIFICATIONS . Storage permissions were either all or none, now API 33 onwards , they can be fine-grained at the level of audio, video, and images. Background code execution restrictions keeps changing subtly in every release. Media notifications were changed in a backward-incompatible in API 33 onwards. This long thread explains the pain of a lot of developers. Crucial third-party libraries have been deprecated # Several popular third-party have been deprecated or are no longer maintained. Picasso # Picasso was great for image loading and has been deprecated . It has been replaced with coil but the upgrade is not trivial. Glide # Glide an alternative to Picasso was last released in Sep 2023. OkHttp # OkHttp which even Android uses internally for implementing HttpURLConnection has not seen a stable release since Oct 2023, the last stable release was 4.12.0 and even the last alpha release was in April 2024. OkHttp 4.12.0 does not support Happy Eyeballs which is a major issue with IPv6 networks. EventBus # EventBus was the de-facto event passing library for Android. And it is unmaintained now. RateThisApp # RateThisApp was good to get app ratings, and then it was abandoned. I don’t blame the maintainers here. If you use an open-source library, you have to be prepared for the fact that it may not be maintained. I am just pointing out, how some of the obvious boilerplate tasks that one requires for building an Android app are suddenly in a limbo. Two different versioning schemes for everything # Android has two versioning schemes , Android API version is for developers and Android version for marketing. For example, Android 11 is API 30, Android 12 is API 31 as well as 32(!), Android 13 is API 33, Android 14 is API 34. The developer documents would reference one scheme or the other or sometimes both! And you are supposed to memorize the mappings while trying to debug issues using GitHub issues or StackOverflow. It just adds unnecessary friction and confusion. Forced upgrades # There are multiple versions in an Android app, all tightly coupled with each other. minSdkVersion and targetSdkVersion of the app Java sourceCompatibility and targetCompatibility version of dependencies version of Android build tool chain version of Gradle version of Android Studio You might think that all updates are optional, but they aren’t Gradle and Android Studio must be upgraded together for version-compatibility Upgrading Java sourceCompatibility and targetCompatibility requires upgrading Gradle (and hence, Android Studio) Upgrading Android build tool chain requires upgrading minSdkVersion and targetSdkVersion Upgrade Android build tool chain requires upgrading Gradle version Also, if you want to stay on an old library like Exoplayer V2, sooner or later, it will become incompatible with other dependencies, and you will be forced to upgrade to media3! You see how you are forced to upgrade almost everything or nothing? And what if you decide to not upgrade any of these? Well, your app will get delisted if the minSdkVersion is too old. Conclusion # Compared to server-side development, Android development requires a bit more efforts to maintain. So, if you are planning to build an Android app as a hobby, keep the ongoing maintenance cost in mind. Update # After this article became popular on Hacker News , I learnt two more issues App published for the first time after 2021, have to hand over signing keys to Google Play Store Further, multiple people suggested that I should use F-droid to publish apps. The problem is that F-droid not only have very little reach but also it cannot solve for backward-incompatible changes to the underlying platform, abandoned libraries, and backward-incompatible changes to Android libraries.",
    "summary": "7-minute read",
    "url": "https://ashishb.net/programming/maintaining-android-app/?utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "ai",
    "word_count": 1367,
    "content_extraction_status": "success"
  },
  {
    "title": "magic namerefs",
    "content": "namerefs (introduced in bash 4.0) act as aliases for other variables var=meow declare -n ref=var echo $ref # prints meow ref=moo echo $var # prints moo they can also reference a specific element in an array, using declare -n ref='array[1234]' using this, i have been playing with a neat nameref trick: tmp=() declare -n var= ' tmp[tmp[0]=some_expression_here, 0] ' it uses the auxiliary array tmp to force an arithmetic context, in which it assigns the result of any arbitrary expression to an element of that array, then expands that same element. we can now create magic variables that evaluate any arbitrary expression. here's a basic counter: tmp=() x=0 declare -n counter= ' tmp[tmp[0]=x++,0] ' for i in {1..10} ; do echo $counter done # prints 0 1 2 3 4 5 6 7 8 9 here's an example that computes the fibonacci numbers: f=(0 1) declare -n fib= ' f[f[2]=f[0], f[0]+=f[1], f[1]=f[2], 0] ' for i in {1..10} ; do echo $fib done # prints 1 1 2 3 5 8 13 21 34 55 this is already very powerful, as it can do many magic things with numbers. but as it turns out, we can do even more: we can use dollar expansions too! here's a silly clock with magic variables that show the current date and time: # \\D{your-format-here} passes that format to strftime # but it only works in prompts like $PS1 # ${var@P} expands $var as if it was in your $PS1 date=( ' \\D{% ' {Y,m,d,H,M,S}}) # the formats we'll use months=(- jan feb mar apr may jun jul aug sep oct nov dec) numbers=({00..60}) tmp=() declare -n year= ' tmp[tmp=${date[0]@P},0] ' declare -n month= ' months[10#${date[1]@P}] ' declare -n day= ' numbers[10#${date[2]@P}] ' declare -n hour= ' numbers[10#${date[3]@P}] ' declare -n minute= ' numbers[10#${date[4]@P}] ' declare -n second= ' numbers[10#${date[5]@P}] ' while : ; do echo $year / $month / $day $hour : $minute : $second sleep 1 done # 2025/jun/06 09:54:13 # 2025/jun/06 09:54:14 # 2025/jun/06 09:54:15 # 2025/jun/06 09:54:16 this is probably one of the coolest things i've ever seen in bash. honestly i am a bit horrified that this works at all, but the resulting code is just so simple and elegant. and it feels like i'm just scratching the surface, there's so much potential. previous: recursive expansions",
    "summary": "2-minute read",
    "url": "https://gist.github.com/izabera/e4717562e20eb6cfb6e05f8019883efb?utm_source=tldrnewsletter",
    "published_date": "2025-06-09T00:00:00",
    "category": "dev",
    "word_count": 387,
    "content_extraction_status": "success"
  }
]